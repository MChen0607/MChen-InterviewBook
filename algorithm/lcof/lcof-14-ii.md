# 14 -Ⅱ 剪绳子Ⅱ【数学/快速幂】

## 1.题目描述

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k\[0\],k\[1\]...k\[m - 1\] 。请问 k\[0\]\*k\[1\]...\*k\[m - 1\] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**示例 1：**

> 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1

**示例 2:**

> 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

**提示：**

* 2 &lt;= n &lt;= 1000

## 2.解题思路

### 2.1 方法一：数学+快速幂

> 基本思路同[14-Ⅰ剪绳子](lc0f-14-i.md)是一样的，通过数学公式求导推理可以得出，在分段的过程中，尽可能让每段都为3的情况下，乘积是最大的。
>
> 由于此题的N较大，会出现大数情况，所以对求解3的times次方采用**快速幂**的方式进行求解。

#### 代码实现

```text
public int cuttingRope(int n) {
    if (n <= 3) {
        return n - 1;
    }
    long res = 1;
    long x = 3;
    int times = n / 3;
    if (n - times * 3 == 1) {//当分完数为3的times段后，还剩1时，会发现 1 3的乘积小于2 2的乘积，所以此情况需要减少一次分为3的段。
        times--;
    }
    int mod = (n - times * 3) / 2;
    while (times != 0) {//快速幂
        res = (times & 1) == 1 ? (res * x) % 1000000007 : res;
        times /= 2;
        x = x * x % 1000000007;
    }
    return (int) (res * Math.pow(2, mod) % 1000000007);
}
```

#### 复杂度分析

> 时间复杂度：O\(log2t\) t为times
>
> 空间复杂度：O\(1\)

## 3.参考

* [https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof)

